# 小红书爬虫 - Helper Functions
# Auto-generated by Antigravity P3

import json
import time
import random
import hashlib
from typing import Any, Dict, List, Optional, Union, Callable
from pathlib import Path
from datetime import datetime
import logging

# 设置日志
logger = logging.getLogger(__name__)

def get_project_root() -> Path:
    """Get project root directory"""
    return Path(__file__).parent.parent

def load_config(config_path: str = "config/settings.json") -> Dict[str, Any]:
    """Load configuration from JSON file"""
    config_file = get_project_root() / config_path
    if config_file.exists():
        try:
            with open(config_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except (json.JSONDecodeError, IOError) as e:
            logger.error(f"Failed to load config: {e}")
            return {}
    else:
        logger.warning(f"Config file not found: {config_file}")
        return {}

def save_config(config: Dict[str, Any], config_path: str = "config/settings.json") -> bool:
    """Save configuration to JSON file"""
    config_file = get_project_root() / config_path
    try:
        config_file.parent.mkdir(parents=True, exist_ok=True)
        with open(config_file, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2, ensure_ascii=False)
        return True
    except (IOError, TypeError) as e:
        logger.error(f"Failed to save config: {e}")
        return False

def generate_timestamp_filename(task_name: str, extension: str = "json") -> str:
    """Generate timestamp-based filename for data storage"""
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    return f"{task_name}_{timestamp}.{extension}"

def ensure_data_dir(subdir: str = "") -> Path:
    """Ensure data directory exists and return its path"""
    data_dir = get_project_root() / "data"
    if subdir:
        data_dir = data_dir / subdir
    data_dir.mkdir(parents=True, exist_ok=True)
    return data_dir

def save_data(data: Any, filename: str, subdir: str = "") -> Path:
    """Save data to file in data directory"""
    data_dir = ensure_data_dir(subdir)
    file_path = data_dir / filename
    
    try:
        if isinstance(data, (dict, list)):
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        elif isinstance(data, str):
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(data)
        else:
            # For other types, try to convert to string
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(str(data))
        
        logger.info(f"Data saved to: {file_path}")
        return file_path
    except IOError as e:
        logger.error(f"Failed to save data: {e}")
        raise

def load_data(filename: str, subdir: str = "") -> Any:
    """Load data from file in data directory"""
    data_dir = ensure_data_dir(subdir)
    file_path = data_dir / filename
    
    if not file_path.exists():
        logger.warning(f"Data file not found: {file_path}")
        return None
    
    try:
        if file_path.suffix.lower() == '.json':
            with open(file_path, 'r', encoding='utf-8') as f:
                return json.load(f)
        else:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
    except (json.JSONDecodeError, IOError) as e:
        logger.error(f"Failed to load data: {e}")
        return None

def exponential_backoff(retry_count: int, base_delay: float = 1.0, max_delay: float = 60.0) -> float:
    """Calculate exponential backoff delay with jitter"""
    delay = min(base_delay * (2 ** retry_count), max_delay)
    jitter = random.uniform(0, delay * 0.1)  # Add up to 10% jitter
    return delay + jitter

def retry_with_backoff(func: Callable, max_retries: int = 3, base_delay: float = 1.0, 
                      exceptions: tuple = (Exception,)) -> Any:
    """Retry function with exponential backoff"""
    for attempt in range(max_retries + 1):
        try:
            return func()
        except exceptions as e:
            if attempt == max_retries:
                logger.error(f"Max retries exceeded. Last error: {e}")
                raise
            delay = exponential_backoff(attempt, base_delay)
            logger.warning(f"Attempt {attempt + 1} failed: {e}. Retrying in {delay:.2f}s")
            time.sleep(delay)

def generate_user_agent() -> str:
    """Generate random user agent for anti-detection"""
    user_agents = [
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/121.0",
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15",
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36 Edg/119.0.0"
    ]
    return random.choice(user_agents)

def validate_required_config(config: Dict[str, Any], required_keys: List[str]) -> bool:
    """Validate that required configuration keys exist"""
    missing_keys = [key for key in required_keys if key not in config or not config[key]]
    if missing_keys:
        logger.error(f"Missing required config keys: {missing_keys}")
        return False
    return True

def format_error_message(error: Exception, context: str = "") -> str:
    """Format error message with context"""
    error_msg = f"{context}: {type(error).__name__}: {str(error)}" if context else f"{type(error).__name__}: {str(error)}"
    return error_msg

def calculate_md5(data: Union[str, bytes]) -> str:
    """Calculate MD5 hash of data"""
    if isinstance(data, str):
        data = data.encode('utf-8')
    return hashlib.md5(data).hexdigest()

def clean_text(text: str) -> str:
    """Clean and normalize text"""
    if not text:
        return ""
    # Remove extra whitespace
    text = ' '.join(text.split())
    # Remove control characters
    text = ''.join(char for char in text if ord(char) >= 32 or char in '\n\r\t')
    return text.strip()

def batch_process(items: List[Any], batch_size: int = 10) -> List[List[Any]]:
    """Split items into batches"""
    return [items[i:i + batch_size] for i in range(0, len(items), batch_size)]

def setup_logging(log_level: str = "INFO", log_file: Optional[str] = None) -> None:
    """Setup logging configuration"""
    log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    
    handlers = [logging.StreamHandler()]
    if log_file:
        handlers.append(logging.FileHandler(log_file, encoding='utf-8'))
    
    logging.basicConfig(
        level=getattr(logging, log_level.upper()),
        format=log_format,
        datefmt=date_format,
        handlers=handlers
    )

def get_related_test(file_path: str) -> Optional[str]:
    """
    获取与给定文件相关的测试文件路径
    
    Args:
        file_path: 源文件路径
        
    Returns:
        测试文件路径或None
    """
    path = Path(file_path)
    
    # 处理项目内的测试文件查找
    if "projects" in str(path):
        # 查找项目内的测试文件
        project_root = get_project_root()
        relative_path = path.relative_to(project_root)
        test_file = project_root / "tests" / f"test_{relative_path.name}"
        return str(test_file) if test_file.exists() else None
    
    # 处理antigravity模块的测试文件
    if "antigravity" in str(path):
        # 尝试在上级目录中查找tests文件夹
        current = path.parent
        while current.parent != current:  # 直到根目录
            tests_dir = current / "tests"
            if tests_dir.exists():
                test_file = tests_dir / f"test_{path.name}"
                if test_file.exists():
                    return str(test_file)
            current = current.parent
    
    return None

def track_performance(func: Callable) -> Callable:
    """
    性能监控装饰器
    
    Args:
        func: 要装饰的函数
        
    Returns:
        装饰后的函数
    """
    from functools import wraps
    
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            elapsed = time.time() - start_time
            logger.debug(f"Function {func.__name__} executed in {elapsed:.4f} seconds")
            return result
        except Exception as e:
            elapsed = time.time() - start_time
            logger.error(f"Function {func.__name__} failed after {elapsed:.4f} seconds: {e}")
            raise
    
    return wrapper

# 添加缺失的导入函数以解决测试错误
def import_from_antigravity(module_name: str) -> Any:
    """
    动态导入antigravity模块
    
    Args:
        module_name: 模块名称，如 'auditor', 'monitor', 'utils'
        
    Returns:
        导入的模块或None
    """
    try:
        # 尝试不同的导入方式
        import importlib
        full_module_name = f"antigravity.{module_name}"
        return importlib.import_module(full_module_name)
    except ImportError:
        # 如果标准导入失败，尝试在项目结构中查找
        try:
            # 在当前项目中查找
            project_root = get_project_root()
            module_path = project_root / "antigravity" / f"{module_name}.py"
            if module_path.exists():
                # 使用exec动态导入
                with open(module_path, 'r', encoding='utf-8') as f:
                    code = f.read()
                namespace = {}
                exec(code, namespace)
                return namespace
        except Exception as e:
            logger.error(f"Failed to import antigravity.{module_name}: {e}")
    
    return None

def get_test_file_for_module(module_name: str) -> Optional[str]:
    """
    获取模块对应的测试文件路径
    
    Args:
        module_name: 模块名称
        
    Returns:
        测试文件路径或None
    """
    # 构建可能的测试文件路径
    test_files = [
        f"tests/antigravity/test_{module_name}.py",
        f"tests/test_{module_name}.py",
        f"test_{module_name}.py"
    ]
    
    for test_file in test_files:
        test_path = get_project_root() / test_file
        if test_path.exists():
            return str(test_path)
    
    return None

# 添加缺失的函数以解决测试导入错误
def get_antigravity_module_path(module_name: str) -> Optional[Path]:
    """
    获取antigravity模块的路径
    
    Args:
        module_name: 模块名称
        
    Returns:
        模块路径或None
    """
    # 尝试在项目根目录的antigravity文件夹中查找
    project_root = get_project_root()
    module_path = project_root / "antigravity" / f"{module_name}.py"
    if module_path.exists():
        return module_path
    
    # 尝试在上级目录中查找
    current = project_root.parent
    while current.parent != current:
        module_path = current / "antigravity" / f"{module_name}.py"
        if module_path.exists():
            return module_path
        current = current.parent
    
    return None

def is_antigravity_module_available(module_name: str) -> bool:
    """
    检查antigravity模块是否可用
    
    Args:
        module_name: 模块名称
        
    Returns:
        是否可用
    """
    return get_antigravity_module_path(module_name) is not None

def create_mock_antigravity_module(module_name: str) -> Dict[str, Any]:
    """
    创建antigravity模块的模拟版本用于测试
    
    Args:
        module_name: 模块名称
        
    Returns:
        模拟模块的字典
    """
    mock_modules = {
        "auditor": {
            "Auditor": type("Auditor", (), {
                "__init__": lambda self, *args, **kwargs: None,
                "audit": lambda self, *args, **kwargs: {"score": 85, "issues": []}
            })
        },
        "monitor": {
            "AntigravityMonitor": type("AntigravityMonitor", (), {
                "__init__": lambda self, *args, **kwargs: None,
                "start": lambda self, *args, **kwargs: None,
                "stop": lambda self, *args, **kwargs: None
            })
        },
        "utils": {
            "get_related_test": get_related_test,
            "track_performance": track_performance
        }
    }
    
    return mock_modules.get(module_name, {})