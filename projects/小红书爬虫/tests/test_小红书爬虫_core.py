# Tests for 小红书爬虫 Core
# Auto-generated by Antigravity P3

import unittest
import sys
import json
from pathlib import Path
from unittest.mock import Mock, patch, AsyncMock
import asyncio

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Import the core module
from core.小红书爬虫_core import 小红书爬虫Core


class Test小红书爬虫Core(unittest.TestCase):
    """Test cases for 小红书爬虫Core module"""
    
    def setUp(self):
        """Set up test environment"""
        self.core = 小红书爬虫Core()
        
    def tearDown(self):
        """Clean up after tests"""
        if hasattr(self.core, 'close'):
            self.core.close()
    
    def test_initialization(self):
        """Test core module initialization"""
        self.assertIsNotNone(self.core)
        self.assertIsInstance(self.core, 小红书爬虫Core)
        
        # Check that config was loaded
        self.assertIsInstance(self.core.config, dict)
        
        # Check that logger was initialized
        self.assertTrue(hasattr(self.core, 'logger'))
    
    def test_config_loading(self):
        """Test that configuration is properly loaded"""
        # Check required config keys exist
        required_keys = ['api_keys', 'settings', 'retry_policy']
        for key in required_keys:
            self.assertIn(key, self.core.config)
        
        # Check retry policy
        retry_policy = self.core.config['retry_policy']
        self.assertIn('max_retries', retry_policy)
        self.assertIn('backoff_factor', retry_policy)
        self.assertGreater(retry_policy['max_retries'], 0)
    
    @patch('core.小红书爬虫_core.requests')
    def test_make_request_success(self, mock_requests):
        """Test successful HTTP request"""
        # Mock response
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {'data': 'test'}
        mock_requests.get.return_value = mock_response
        
        # Test request
        result = self.core._make_request('https://example.com')
        self.assertEqual(result, {'data': 'test'})
        mock_requests.get.assert_called_once()
    
    @patch('core.小红书爬虫_core.requests')
    def test_make_request_retry(self, mock_requests):
        """Test request retry on failure"""
        # Mock first failure, then success
        mock_response_fail = Mock()
        mock_response_fail.status_code = 500
        
        mock_response_success = Mock()
        mock_response_success.status_code = 200
        mock_response_success.json.return_value = {'data': 'success'}
        
        mock_requests.get.side_effect = [
            mock_response_fail,
            mock_response_fail,
            mock_response_success
        ]
        
        # Test request with retry
        result = self.core._make_request('https://example.com')
        self.assertEqual(result, {'data': 'success'})
        self.assertEqual(mock_requests.get.call_count, 3)
    
    @patch('core.小红书爬虫_core.小红书爬虫Core._make_request')
    def test_fetch_user_info(self, mock_make_request):
        """Test fetching user information"""
        # Mock response
        mock_response = {
            'user': {
                'id': '123',
                'name': 'test_user',
                'followers': 1000
            }
        }
        mock_make_request.return_value = mock_response
        
        # Test fetching user info
        user_info = self.core.fetch_user_info('test_user')
        
        self.assertIsInstance(user_info, dict)
        self.assertIn('user', user_info)
        self.assertEqual(user_info['user']['id'], '123')
        mock_make_request.assert_called_once()
    
    @patch('core.小红书爬虫_core.小红书爬虫Core._make_request')
    def test_fetch_posts(self, mock_make_request):
        """Test fetching user posts"""
        # Mock response
        mock_response = {
            'posts': [
                {'id': '1', 'title': 'Post 1'},
                {'id': '2', 'title': 'Post 2'}
            ]
        }
        mock_make_request.return_value = mock_response
        
        # Test fetching posts
        posts = self.core.fetch_posts('test_user', limit=2)
        
        self.assertIsInstance(posts, list)
        self.assertEqual(len(posts), 2)
        self.assertEqual(posts[0]['id'], '1')
        mock_make_request.assert_called_once()
    
    def test_save_data(self):
        """Test saving data to file"""
        test_data = {'test': 'data'}
        task_name = 'test_task'
        
        # Save data
        file_path = self.core.save_data(test_data, task_name)
        
        # Check file was created
        self.assertTrue(file_path.exists())
        
        # Read and verify data
        with open(file_path, 'r', encoding='utf-8') as f:
            saved_data = json.load(f)
        
        self.assertEqual(saved_data, test_data)
        
        # Clean up
        file_path.unlink()
    
    def test_save_data_with_timestamp(self):
        """Test that saved files include timestamp"""
        test_data = {'test': 'data'}
        task_name = 'test_task'
        
        # Save data
        file_path = self.core.save_data(test_data, task_name)
        
        # Check filename format
        filename = file_path.name
        self.assertTrue(filename.startswith(f'{task_name}_'))
        self.assertTrue(filename.endswith('.json'))
        
        # Clean up
        file_path.unlink()
    
    @patch('core.小红书爬虫_core.playwright')
    def test_browser_initialization(self, mock_playwright):
        """Test browser initialization"""
        # Mock playwright
        mock_browser = AsyncMock()
        mock_context = AsyncMock()
        mock_page = AsyncMock()
        
        mock_playwright.async_playwright.return_value.__aenter__.return_value = Mock(
            chromium=Mock(
                launch=AsyncMock(return_value=mock_browser)
            )
        )
        mock_browser.new_context.return_value = mock_context
        mock_context.new_page.return_value = mock_page
        
        # Test async initialization
        async def test_async():
            core = 小红书爬虫Core()
            await core._init_browser()
            self.assertTrue(core.browser_initialized)
            await core.close()
        
        asyncio.run(test_async())
    
    def test_error_handling(self):
        """Test error handling in core methods"""
        # Test with invalid URL
        with self.assertRaises(ValueError):
            self.core._make_request('')
        
        # Test with invalid data for saving
        with self.assertRaises(TypeError):
            self.core.save_data(None, 'test')
    
    def test_process_method(self):
        """Test the main process method"""
        # Mock dependencies
        with patch.object(self.core, 'fetch_user_info') as mock_fetch_user, \
             patch.object(self.core, 'fetch_posts') as mock_fetch_posts, \
             patch.object(self.core, 'save_data') as mock_save_data:
            
            # Setup mocks
            mock_fetch_user.return_value = {'user': {'id': '123'}}
            mock_fetch_posts.return_value = [{'id': '1'}]
            mock_save_data.return_value = Path('test.json')
            
            # Test process
            result = self.core.process({'username': 'test_user', 'limit': 10})
            
            # Verify calls
            mock_fetch_user.assert_called_once_with('test_user')
            mock_fetch_posts.assert_called_once_with('test_user', limit=10)
            self.assertEqual(mock_save_data.call_count, 2)  # User info + posts
            
            # Verify result
            self.assertIsInstance(result, dict)
            self.assertIn('user_info', result)
            self.assertIn('posts', result)
            self.assertIn('saved_files', result)


class Test小红书爬虫CoreAsync(unittest.IsolatedAsyncioTestCase):
    """Async test cases for 小红书爬虫Core"""
    
    async def asyncSetUp(self):
        """Set up async test environment"""
        self.core = 小红书爬虫Core()
    
    async def asyncTearDown(self):
        """Clean up async tests"""
        if hasattr(self.core, 'close'):
            await self.core.close()
    
    @patch('core.小红书爬虫_core.playwright')
    async def test_async_browser_operations(self, mock_playwright):
        """Test async browser operations"""
        # Setup mocks
        mock_browser = AsyncMock()
        mock_page = AsyncMock()
        mock_page.content.return_value = '<html>Test content</html>'
        
        mock_playwright.async_playwright.return_value.__aenter__.return_value = Mock(
            chromium=Mock(
                launch=AsyncMock(return_value=mock_browser)
            )
        )
        mock_browser.new_context.return_value.new_page.return_value = mock_page
        
        # Initialize browser
        await self.core._init_browser()
        
        # Test async page fetch
        content = await self.core._fetch_page_async('https://example.com')
        self.assertEqual(content, '<html>Test content</html>')
        
        # Verify page navigation was called
        mock_page.goto.assert_called_once_with('https://example.com', wait_until='networkidle')


def run_tests():
    """Run all tests and return results"""
    # Create test suite
    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(Test小红书爬虫Core)
    
    # Add async tests
    async_suite = loader.loadTestsFromTestCase(Test小红书爬虫CoreAsync)
    suite.addTest(async_suite)
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    return result


if __name__ == '__main__':
    # Run tests
    result = run_tests()
    
    # Exit with appropriate code
    sys.exit(0 if result.wasSuccessful() else 1)